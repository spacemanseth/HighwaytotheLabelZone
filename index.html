<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Highway to the Label Zone</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jsbarcode/3.11.5/JsBarcode.all.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
</head>
<body class="bg-gray-100">
    <div id="app" class="container mx-auto p-6 max-w-4xl">
        <div class="flex justify-center items-center mb-6">
            <img src="https://i.imgur.com/Z5EqkGm.png" alt="SW Installations Logo" class="mr-4 w-24 h-24">
            <h1 class="text-3xl font-bold text-center text-yellow-600">Highway to the Label Zone!</h1>
        </div>
        
        <div class="bg-blue-50 border-l-4 border-blue-500 p-4 mb-6">
            <p class="text-blue-700">
                This tool converts Plan-o-Gram (POG) PDF files to Avery 6570 labels. The first label will display the POG name,
                followed by product labels filled down vertically in columns. Each product label includes the product name, UIN number,
                and UPC barcode.
            </p>
        </div>
        
        <div id="dropzone" class="border-2 border-dashed rounded-lg p-8 text-center cursor-pointer mb-6 border-gray-300 hover:border-blue-500 hover:bg-blue-50">
            <input id="file-input" type="file" class="hidden" accept=".pdf" multiple>
            <div id="empty-state">
                <svg class="mx-auto h-12 w-12 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path>
                </svg>
                <p class="mt-2 text-sm text-gray-600">
                    Drag & drop POG PDF files here, or click to select files
                </p>
                <p class="text-xs text-gray-500 mt-1">
                    Accepts single or multiple POG PDF files
                </p>
            </div>
            <div id="file-list" class="hidden">
                <p id="file-count" class="text-green-600 font-semibold mb-2"></p>
                <ul id="files" class="text-left max-h-40 overflow-y-auto pl-4"></ul>
                <p class="text-sm text-gray-500 mt-2">Click or drag to change selection</p>
            </div>
        </div>
        
        <div id="error" class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4 hidden"></div>
        
        <div class="flex items-center justify-between mb-6">
            <button id="process-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-6 rounded opacity-50 cursor-not-allowed">
                Generate Labels
            </button>
            
            <div id="label-count" class="text-gray-700 hidden">
                Will generate <span id="label-count-num">0</span> labels
            </div>
        </div>
        
        <div id="progress-container" class="mb-6 hidden">
            <div class="flex justify-between mb-1">
                <span class="text-sm font-medium text-blue-700">Processing...</span>
                <span id="progress-percent" class="text-sm font-medium text-blue-700">0%</span>
            </div>
            <div class="w-full bg-gray-200 rounded-full h-2.5">
                <div id="progress-bar" class="bg-blue-600 h-2.5 rounded-full" style="width: 0%"></div>
            </div>
        </div>
        
        <div id="logs-container" class="mt-6 hidden">
            <h3 class="text-lg font-semibold mb-2">Processing Log</h3>
            <div id="logs" class="bg-gray-100 p-3 rounded-lg max-h-60 overflow-y-auto"></div>
        </div>
        
        <div class="mt-8 bg-gray-50 p-4 rounded-lg">
            <h2 class="text-xl font-semibold mb-2">Instructions</h2>
            <ol class="list-decimal pl-5 space-y-2">
                <li>Drag and drop one or more POG PDF files onto the upload area</li>
                <li>Click the "Generate Labels" button to process the files</li>
                <li>For each POG, a PDF with Avery 6570 labels will be generated and downloaded</li>
                <li>The first label will contain the POG name</li>
                <li>The remaining labels will contain product details in vertical column order (down column 1, then column 2, etc.)</li>
                <li>Each product label includes the product name, UIN number, and UPC barcode</li>
                <li>Print the labels on Avery 6570 label sheets</li>
            </ol>
        </div>
    </div>

    <script>
        // Set PDF.js worker source
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        
        // DOM elements
        const dropzone = document.getElementById('dropzone');
        const fileInput = document.getElementById('file-input');
        const emptyState = document.getElementById('empty-state');
        const fileList = document.getElementById('file-list');
        const fileCount = document.getElementById('file-count');
        const filesContainer = document.getElementById('files');
        const errorContainer = document.getElementById('error');
        const processBtn = document.getElementById('process-btn');
        const labelCountContainer = document.getElementById('label-count');
        const labelCountNum = document.getElementById('label-count-num');
        const progressContainer = document.getElementById('progress-container');
        const progressBar = document.getElementById('progress-bar');
        const progressPercent = document.getElementById('progress-percent');
        const logsContainer = document.getElementById('logs-container');
        const logs = document.getElementById('logs');
        
        // State
        let selectedFiles = [];
        let isProcessing = false;
        let labelCount = 0;
        
        // Event listeners
        dropzone.addEventListener('dragover', e => {
            e.preventDefault();
            dropzone.classList.add('border-blue-500', 'bg-blue-50');
        });
        
        dropzone.addEventListener('dragleave', e => {
            e.preventDefault();
            dropzone.classList.remove('border-blue-500', 'bg-blue-50');
        });
        
        dropzone.addEventListener('drop', e => {
            e.preventDefault();
            dropzone.classList.remove('border-blue-500', 'bg-blue-50');
            handleFiles(e.dataTransfer.files);
        });
        
        dropzone.addEventListener('click', () => {
            fileInput.click();
        });
        
        fileInput.addEventListener('change', e => {
            handleFiles(e.target.files);
        });
        
        processBtn.addEventListener('click', processPDFs);
        
        // Functions
        function handleFiles(files) {
            errorContainer.classList.add('hidden');
            
            const acceptedFiles = Array.from(files).filter(file => file.type === 'application/pdf');
            
            if (acceptedFiles.length === 0) {
                showError("Please upload PDF files only");
                return;
            }
            
            selectedFiles = acceptedFiles;
            updateFileList();
            updateProcessButton();
        }
        
        function updateFileList() {
            if (selectedFiles.length === 0) {
                emptyState.classList.remove('hidden');
                fileList.classList.add('hidden');
                return;
            }
            
            emptyState.classList.add('hidden');
            fileList.classList.remove('hidden');
            
            fileCount.textContent = `${selectedFiles.length} file${selectedFiles.length !== 1 ? 's' : ''} selected`;
            
            filesContainer.innerHTML = '';
            selectedFiles.forEach(file => {
                const li = document.createElement('li');
                li.className = 'text-gray-700 truncate';
                li.textContent = `${file.name} (${(file.size / 1024).toFixed(1)} KB)`;
                filesContainer.appendChild(li);
            });
        }
        
        function updateProcessButton() {
            if (selectedFiles.length > 0 && !isProcessing) {
                processBtn.classList.remove('opacity-50', 'cursor-not-allowed');
                processBtn.disabled = false;
            } else {
                processBtn.classList.add('opacity-50', 'cursor-not-allowed');
                processBtn.disabled = true;
            }
        }
        
        function showError(message) {
            errorContainer.textContent = message;
            errorContainer.classList.remove('hidden');
        }
        
        function addLog(message) {
            const logEntry = document.createElement('div');
            logEntry.className = 'text-sm py-1';
            logEntry.textContent = message;
            logs.appendChild(logEntry);
            logsContainer.classList.remove('hidden');
        }
        
        function updateProgress(percent) {
            progressBar.style.width = `${percent}%`;
            progressPercent.textContent = `${Math.round(percent)}%`;
        }
        
        async function readFileAsBuffer(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = e => resolve(e.target.result);
                reader.onerror = e => reject(new Error("Failed to read file"));
                reader.readAsArrayBuffer(file);
            });
        }
        
        async function processPDFs() {
            if (selectedFiles.length === 0) {
                showError("Please select at least one POG PDF file");
                return;
            }
            
            try {
                isProcessing = true;
                updateProcessButton();
                
                progressContainer.classList.remove('hidden');
                updateProgress(0);
                logs.innerHTML = '';
                logsContainer.classList.remove('hidden');
                
                for (let i = 0; i < selectedFiles.length; i++) {
                    const file = selectedFiles[i];
                    addLog(`Processing ${file.name}...`);
                    
                    try {
                        // Read the PDF file content
                        const fileBuffer = await readFileAsBuffer(file);
                        
                        // Use pdfjs to extract text from PDF
                        await extractTextFromPDF(fileBuffer, file.name);
                        
                        updateProgress(((i + 1) / selectedFiles.length) * 100);
                    } catch (err) {
                        addLog(`Error processing ${file.name}: ${err.message}`);
                        console.error(`Error processing ${file.name}:`, err);
                    }
                }
                
                addLog("All files processed!");
            } catch (err) {
                console.error("Error processing files:", err);
                showError(`Error: ${err.message || "Unknown error processing files"}`);
            } finally {
                isProcessing = false;
                updateProcessButton();
            }
        }
        
        async function extractTextFromPDF(fileBuffer, fileName) {
            try {
                // Load PDF document
                const loadingTask = pdfjsLib.getDocument({ data: fileBuffer });
                const pdf = await loadingTask.promise;
                
                addLog(`PDF loaded: ${fileName} (${pdf.numPages} pages)`);
                
                // Extract text from all pages
                let extractedText = '';
                for (let i = 1; i <= pdf.numPages; i++) {
                    const page = await pdf.getPage(i);
                    const textContent = await page.getTextContent();
                    const pageText = textContent.items.map(item => item.str).join(' ');
                    extractedText += pageText + '\n';
                }
                
                // Parse the POG data
                const { pogName, products } = parseProductData(extractedText);
                addLog(`Extracted ${products.length} products from ${pogName}`);
                
                // Generate the labels PDF
                await generateLabels(pogName, products, fileName);
                
            } catch (error) {
                console.error("Error extracting text from PDF:", error);
                throw new Error(`Failed to extract text from PDF: ${error.message}`);
            }
        }
        
        function parseProductData(text) {
            const lines = text.split('\n');
            const products = [];
            let pogName = "";
            
            // Try to extract POG name from the first few lines
            for (let i = 0; i < 5; i++) {
                if (lines[i] && lines[i].includes("(Cigs") && !pogName) {
                    pogName = lines[i].trim();
                    break;
                }
            }
            
            if (!pogName && lines[0]) {
                pogName = lines[0].trim(); // Default to first line if specific pattern not found
            }

            // Regular expressions to match product data
            const upcPattern = /(\d{12})/;
            const uinPattern = /\b(\d{6,7})\b/;
            
            // Process each line to extract product data
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                
                // Look for lines with UPC code pattern (12 digits)
                if (upcPattern.test(line)) {
                    try {
                        const upcMatch = line.match(upcPattern);
                        const uinMatch = line.match(uinPattern);
                        
                        if (upcMatch) {
                            const upc = upcMatch[1];
                            const uin = uinMatch ? uinMatch[1] : "N/A";
                            
                            // Extract product name
                            // Remove UPC and UIN from the line
                            let name = line.replace(upc, '').trim();
                            if (uin !== "N/A") {
                                name = name.replace(uin, '').trim();
                            }
                            
                            // Clean up numbers and special chars
                            name = name.replace(/^\d+\s+/, '').trim();
                            
                            // Remove size/UOM info
                            name = name.replace(/\d+\.\d+(?:CT|OZ).*$/, '').trim();
                            
                            // Skip entries that don't seem to have proper data
                            if (name && name.length > 2) {
                                products.push({
                                    name: name,
                                    uin: uin,
                                    upc: upc
                                });
                            }
                        }
                    } catch (err) {
                        console.error("Error parsing line:", line, err);
                    }
                }
            }
            
            labelCount = products.length + 1; // +1 for POG name label
            labelCountContainer.classList.remove('hidden');
            labelCountNum.textContent = labelCount;
            
            return { pogName, products };
        }
        
        async function generateLabels(pogName, products, fileName) {
            try {
                // Create canvas to draw labels
                const canvas = document.createElement('canvas');
                canvas.width = 8.5 * 72 * 4; // 8.5 inches at 288 DPI
                canvas.height = 11 * 72 * 4; // 11 inches at 288 DPI
                const ctx = canvas.getContext('2d');
                
                // White background
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Setup colors and fonts
                ctx.fillStyle = 'black';
                ctx.textBaseline = 'top';
                
                // Define label dimensions for Avery 6570 (1.75" x 0.5" labels, 4 across, 20 down)
                const dpi = 288; // 4x the standard 72 DPI for better quality
                const labelWidth = 1.75 * dpi;
                const labelHeight = 0.5 * dpi;
                const pageMarginX = 0.31 * dpi;
                const pageMarginY = 0.5 * dpi;
                const gapX = 0.19 * dpi;
                const gapY = 0;
                const cols = 4;
                const rows = 20;
                
                // Create the first label with POG name
                const allItems = [{ name: pogName, uin: 'POG Name', upc: '' }];
                
                // Add products to the items array
                allItems.push(...products);

                // Function to draw text with word wrap
                const drawWrappedText = (text, x, y, maxWidth, lineHeight, bold = false) => {
                    ctx.font = bold ? `bold ${Math.floor(dpi/50)}px Arial` : `${Math.floor(dpi/50)}px Arial`;
                    
                    const words = text.split(' ');
                    let line = '';
                    let offsetY = 0;
                    let lineCount = 0;
                    
                    for (const word of words) {
                        const testLine = line + (line ? ' ' : '') + word;
                        const metrics = ctx.measureText(testLine);
                        
                        if (metrics.width > maxWidth && line !== '') {
                            ctx.fillText(line, x, y + offsetY);
                            line = word;
                            offsetY += lineHeight;
                            lineCount++;
                            
                            // Limit to 2 lines
                            if (lineCount >= 1 && bold) {
                                line += '...';
                                break;
                            }
                        } else {
                            line = testLine;
                        }
                    }
                    
                    ctx.fillText(line, x, y + offsetY);
                    return offsetY + lineHeight;
                };
                
                // Fill labels vertically (down column 1, then column 2, etc.)
                for (let i = 0; i < Math.min(allItems.length, cols * rows); i++) {
                    // Calculate position based on vertical fill pattern
                    const col = Math.floor(i / rows);
                    const row = i % rows;
                    
                    const x = pageMarginX + col * (labelWidth + gapX);
                    const y = pageMarginY + row * (labelHeight + gapY);
                    
                    const item = allItems[i];
                    
                    // Draw a light border around the label (for debugging/alignment)
                    ctx.strokeStyle = '#EEEEEE';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(x, y, labelWidth, labelHeight);
                    
                    // Draw product name (bold)
                    let textY = y + dpi/50;
                    textY += drawWrappedText(item.name, x + dpi/30, textY, labelWidth - dpi/15, dpi/30, true);
                    
                    // Draw UIN
                    textY += drawWrappedText(`UIN: ${item.uin}`, x + dpi/30, textY, labelWidth - dpi/15, dpi/30);
                    
                    // Draw barcode if UPC exists
                    if (item.upc) {
                        // We'll use JsBarcode to create the barcode
                        // First, create a new canvas for the barcode
                        const barcodeCanvas = document.createElement('canvas');
                        try {
                            JsBarcode(barcodeCanvas, item.upc, {
                                format: "upc",
                                width: 1.5,
                                height: 30,
                                displayValue: false,
                                margin: 0
                            });
                            
                            // Draw the barcode image on our main canvas
                            const barcodeWidth = labelWidth * 0.8;
                            const barcodeHeight = labelHeight * 0.4;
                            const barcodeX = x + (labelWidth - barcodeWidth) / 2;
                            const barcodeY = y + labelHeight - barcodeHeight - dpi/40;
                            
                            ctx.drawImage(barcodeCanvas, barcodeX, barcodeY, barcodeWidth, barcodeHeight);
                            
                            // Draw UPC number under barcode
                            ctx.font = `${Math.floor(dpi/60)}px Arial`;
                            const upcWidth = ctx.measureText(item.upc).width;
                            ctx.fillText(item.upc, x + (labelWidth - upcWidth) / 2, y + labelHeight - dpi/40);
                        } catch (err) {
                            console.error(`Error creating barcode for ${item.upc}:`, err);
                        }
                    }
                }

                // Convert canvas to PDF
                if (window.jspdf && window.jspdf.jsPDF) {
                    // Create PDF using jspdf
                    const orientation = canvas.width > canvas.height ? 'l' : 'p';
                    const pdf = new window.jspdf.jsPDF({
                        orientation: orientation,
                        unit: 'in',
                        format: [8.5, 11]
                    });
                    
                    // Add canvas as image to PDF
                    const imgData = canvas.toDataURL('image/png');
                    pdf.addImage(imgData, 'PNG', 0, 0, 8.5, 11);
                    
                    // Save PDF
                    pdf.save(`${fileName.replace('.pdf', '')}_labels.pdf`);
                    addLog(`Generated labels PDF for ${fileName}`);
                } else {
                    // jsPDF library not loaded - offer canvas download instead
                    const link = document.createElement('a');
                    link.download = `${fileName.replace('.pdf', '')}_labels.png`;
                    link.href = canvas.toDataURL('image/png');
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    addLog(`Generated labels PNG for ${fileName} (PDF library not loaded)`);
                }
                
            } catch (error) {
                console.error("Error generating labels:", error);
                throw new Error(`Failed to generate labels: ${error.message}`);
            }
        }
    </script>
</body>
</html>